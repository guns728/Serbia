<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Image Particle Visualizer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* æ§åˆ¶é¢æ¿æ ·å¼ */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 280px;
            padding: 20px;
            background: rgba(20, 20, 30, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 100;
            transition: opacity 0.3s;
        }

        h2 {
            margin: 0 0 15px 0;
            font-size: 1.2rem;
            letter-spacing: 1px;
            color: #00e5ff;
            text-transform: uppercase;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        input[type="range"] {
            width: 100%;
            background: transparent;
            -webkit-appearance: none;
            margin: 5px 0;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #00e5ff;
            margin-top: -6px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 229, 255, 0.5);
            transition: transform 0.1s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        /* æ–‡ä»¶ä¸Šä¼ æŒ‰é’®ç¾åŒ– */
        .file-upload {
            position: relative;
            display: inline-block;
            width: 100%;
            margin-bottom: 20px;
        }

        .file-upload input[type="file"] {
            display: none;
        }

        .file-upload-label {
            display: block;
            padding: 12px;
            background: linear-gradient(45deg, #00e5ff, #2979ff);
            color: #fff;
            text-align: center;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9rem;
            transition: filter 0.2s;
        }

        .file-upload-label:hover {
            filter: brightness(1.1);
        }

        .tips {
            font-size: 0.75rem;
            color: #666;
            margin-top: 10px;
            line-height: 1.4;
        }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00e5ff;
            font-size: 1.5rem;
            display: none;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui-panel">
        <h2>ç²’å­é€è§†ç”Ÿæˆå™¨</h2>
        
        <div class="file-upload">
            <label for="imageInput" class="file-upload-label">ğŸ“ ä¸Šä¼ å›¾ç‰‡</label>
            <input type="file" id="imageInput" accept="image/*">
        </div>

        <div class="control-group">
            <label>ç²’å­å¯†åº¦ (é‡‡æ ·ç‡) <span id="val-density">2</span></label>
            <input type="range" id="inp-density" min="1" max="6" step="1" value="2">
        </div>

        <div class="control-group">
            <label>ç²’å­å¤§å° <span id="val-size">2.0</span></label>
            <input type="range" id="inp-size" min="0.5" max="10.0" step="0.1" value="2.0">
        </div>

        <div class="control-group">
            <label>3D æ·±åº¦å¼ºåº¦ <span id="val-depth">100</span></label>
            <input type="range" id="inp-depth" min="0" max="500" step="10" value="100">
        </div>

        <div class="control-group">
            <label>é¢œè‰²é˜ˆå€¼ (è¿‡æ»¤é»‘è‰²) <span id="val-threshold">10</span></label>
            <input type="range" id="inp-threshold" min="0" max="100" step="1" value="10">
        </div>

        <div class="tips">
            æç¤ºï¼š<br>
            â€¢ é¼ æ ‡å·¦é”®æ‹–åŠ¨æ—‹è½¬<br>
            â€¢ æ»šè½®ç¼©æ”¾<br>
            â€¢ å›¾ç‰‡è¶Šäº®çš„éƒ¨åˆ†ç²’å­è¶Šå‡¸å‡º<br>
            â€¢ å¯†åº¦æ•°å€¼è¶Šå°ï¼Œç²’å­è¶Šå¤š(è¶Šå¡)
        </div>
    </div>

    <div id="loading">PROCESSING...</div>
    <div id="canvas-container"></div>

    <!-- å¼•å…¥ Three.js -->
    <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- å˜é‡å®šä¹‰ ---
        let scene, camera, renderer, controls;
        let particlesMesh;
        let originalImageData = null; // å­˜å‚¨åŸå§‹å›¾ç‰‡æ•°æ®
        let imageWidth = 0, imageHeight = 0;

        // --- DOM å…ƒç´  ---
        const container = document.getElementById('canvas-container');
        const fileInput = document.getElementById('imageInput');
        const loadingDiv = document.getElementById('loading');
        
        // å‚æ•°å¼•ç”¨
        const params = {
            density: 2,    // é‡‡æ ·é—´éš” (è¶Šå°ç²’å­è¶Šå¤š)
            size: 2.0,     // ç²’å­å¤§å°
            depth: 100,    // Zè½´æŒ¤å‡ºå¼ºåº¦
            threshold: 10  // å‰”é™¤æš—éƒ¨çš„é˜ˆå€¼
        };

        // --- åˆå§‹åŒ– Three.js åœºæ™¯ ---
        function init() {
            // 1. åœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.001); // å¢åŠ ä¸€ç‚¹é›¾æ°”å¢åŠ æ·±é‚ƒæ„Ÿ

            // 2. ç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 500;
            camera.position.y = 100;

            // 3. æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // 4. æ§åˆ¶å™¨ (é¼ æ ‡äº¤äº’)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.5;

            // 5. ç›‘å¬çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', onWindowResize);

            // 6. ç»‘å®šUIäº‹ä»¶
            bindUI();

            // 7. å¼€å§‹å¾ªç¯
            animate();
            
            // åŠ è½½ä¸€ä¸ªé»˜è®¤çš„å ä½æç¤ºï¼Œæˆ–è€…åªæ˜¯ä¿æŒé»‘å±ç­‰å¾…ä¸Šä¼ 
            createPlaceholder();
        }

        // --- åˆ›å»ºåˆå§‹å ä½æ•ˆæœ ---
        function createPlaceholder() {
            const geometry = new THREE.BufferGeometry();
            const count = 1000;
            const positions = new Float32Array(count * 3);
            for(let i=0; i<count * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 600;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: 0x333333, size: 2 });
            particlesMesh = new THREE.Points(geometry, material);
            scene.add(particlesMesh);
        }

        // --- å¤„ç†å›¾ç‰‡ä¸Šä¼  ---
        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            loadingDiv.style.display = 'block';

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    processImage(img);
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        // --- å›¾ç‰‡å¤„ç†é€»è¾‘ ---
        function processImage(img) {
            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„ Canvas æ¥è¯»å–åƒç´ æ•°æ®
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // é™åˆ¶æœ€å¤§åˆ†è¾¨ç‡ä»¥é˜²å´©æºƒï¼Œå¤ªå¤§å›¾ç‰‡è¿›è¡Œç¼©æ”¾
            const maxWidth = 1000; 
            let w = img.width;
            let h = img.height;
            
            if (w > maxWidth) {
                h = Math.round(h * (maxWidth / w));
                w = maxWidth;
            }

            canvas.width = w;
            canvas.height = h;
            ctx.drawImage(img, 0, 0, w, h);

            imageWidth = w;
            imageHeight = h;
            originalImageData = ctx.getImageData(0, 0, w, h); // è·å–æ‰€æœ‰åƒç´ æ•°æ®

            generateParticles();
            loadingDiv.style.display = 'none';
        }

        // --- æ ¸å¿ƒï¼šç”Ÿæˆç²’å­ ---
        function generateParticles() {
            if (!originalImageData) return;

            // ç§»é™¤æ—§çš„ç²’å­ç³»ç»Ÿ
            if (particlesMesh) {
                scene.remove(particlesMesh);
                particlesMesh.geometry.dispose();
                particlesMesh.material.dispose();
            }

            const { data, width, height } = originalImageData;
            const density = params.density;
            const threshold = params.threshold;

            const vertices = [];
            const colors = [];

            // éå†åƒç´ 
            // ä¸ºäº†å±…ä¸­ï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®— offset
            const xOffset = width / 2;
            const yOffset = height / 2;

            for (let y = 0; y < height; y += density) {
                for (let x = 0; x < width; x += density) {
                    // è·å–åƒç´ ç´¢å¼• (RGBA 4ä¸ªå€¼ä¸€ç»„)
                    const index = (y * width + x) * 4;
                    const r = data[index];
                    const g = data[index + 1];
                    const b = data[index + 2];
                    const a = data[index + 3];

                    // å¦‚æœå®Œå…¨é€æ˜ï¼Œæˆ–è€…äº®åº¦ä½äºé˜ˆå€¼ï¼Œåˆ™è·³è¿‡
                    const brightness = (r + g + b) / 3;
                    if (a === 0 || brightness < threshold) continue;

                    // è®¡ç®—ä½ç½®
                    // X: æ°´å¹³ä½ç½® (å‡å»åç§»é‡ä»¥å±…ä¸­)
                    // Y: å‚ç›´ä½ç½® (æ³¨æ„ Canvas Y è½´å‘ä¸‹ï¼Œ3D Y è½´å‘ä¸Šï¼Œéœ€è¦åè½¬)
                    // Z: æ·±åº¦ (åŸºäºäº®åº¦ï¼Œè¶Šäº®è¶Šé å‰)
                    const pX = x - xOffset;
                    const pY = -(y - yOffset); // åè½¬Yè½´
                    const pZ = (brightness / 255) * params.depth; // æ˜ å°„æ·±åº¦

                    vertices.push(pX, pY, pZ);

                    // é¢œè‰²å½’ä¸€åŒ– (0.0 - 1.0)
                    colors.push(r / 255, g / 255, b / 255);
                }
            }

            // åˆ›å»º BufferGeometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            // åˆ›å»ºæè´¨
            // vertexColors: true ä½¿å¾—æ¯ä¸ªç²’å­ä½¿ç”¨æˆ‘ä»¬ä¼ å…¥çš„ color æ•°ç»„
            const material = new THREE.PointsMaterial({
                size: params.size,
                vertexColors: true,
                sizeAttenuation: true, // è·ç¦»è¶Šè¿œçœ‹èµ·æ¥è¶Šå°
                transparent: true,
                opacity: 0.9
            });

            particlesMesh = new THREE.Points(geometry, material);
            
            // ç¨å¾®æ—‹è½¬ä¸€ä¸‹ï¼Œè®©3Dæ•ˆæœæ›´æ˜æ˜¾
            particlesMesh.rotation.x = -0.1; 
            particlesMesh.rotation.y = 0.1;

            scene.add(particlesMesh);

            // è°ƒæ•´ç›¸æœºä½ç½®ä»¥é€‚åº”å›¾ç‰‡å¤§å°
            const maxDim = Math.max(width, height);
            camera.position.z = maxDim * 1.5; 
        }

        // --- ç»‘å®š UI äº‹ä»¶ ---
        function bindUI() {
            // å¯†åº¦
            const inpDensity = document.getElementById('inp-density');
            inpDensity.addEventListener('input', (e) => {
                params.density = parseInt(e.target.value);
                document.getElementById('val-density').innerText = params.density;
            });
            inpDensity.addEventListener('change', generateParticles); // ä»…åœ¨æ¾å¼€æ—¶é‡æ–°ç”Ÿæˆï¼Œé¿å…å¡é¡¿

            // å¤§å°
            const inpSize = document.getElementById('inp-size');
            inpSize.addEventListener('input', (e) => {
                params.size = parseFloat(e.target.value);
                document.getElementById('val-size').innerText = params.size.toFixed(1);
                // å¤§å°æ”¹å˜ä¸éœ€è¦é‡æ„å‡ ä½•ä½“ï¼Œåªéœ€æ›´æ–°æè´¨
                if(particlesMesh) particlesMesh.material.size = params.size;
            });

            // æ·±åº¦
            const inpDepth = document.getElementById('inp-depth');
            inpDepth.addEventListener('input', (e) => {
                params.depth = parseInt(e.target.value);
                document.getElementById('val-depth').innerText = params.depth;
            });
            inpDepth.addEventListener('change', generateParticles);

            // é˜ˆå€¼
            const inpThreshold = document.getElementById('inp-threshold');
            inpThreshold.addEventListener('input', (e) => {
                params.threshold = parseInt(e.target.value);
                document.getElementById('val-threshold').innerText = params.threshold;
            });
            inpThreshold.addEventListener('change', generateParticles);
        }

        // --- çª—å£å¤§å°è°ƒæ•´ ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // å¿…é¡»è°ƒç”¨ï¼Œå› ä¸ºå¼€å¯äº† damping
            
            // ç»™ç²’å­ä¸€ä¸ªæå…¶ç¼“æ…¢çš„è‡ªè½¬ï¼Œå¢åŠ åŠ¨æ€æ„Ÿ
            if (particlesMesh && !originalImageData) {
                // ä»…åœ¨æ¼”ç¤ºæ¨¡å¼ä¸‹è‡ªè½¬
                particlesMesh.rotation.y += 0.001;
            }

            renderer.render(scene, camera);
        }

        // å¯åŠ¨
        init();

    </script>
</body>
</html>